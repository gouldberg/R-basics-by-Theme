y = dat[discords[1,2]:(discords[1,2] + 100)], col = "red")
discords <- find_discords_hotsax(dat, w_size = 100, paa_size = 4, a_size = 4, n_threshold = 0.01, discords_num = 20)
discords
# -->
# The best discord is the first one at 4233:
graphics.off()
par(mfrow = c(1,1))
plot(dat, type = "l", col = "cornflowerblue")
lines(x = c(discords[1,2]:(discords[1,2] + 100)),
y = dat[discords[1,2]:(discords[1,2] + 100)], col = "red")
discords <- find_discords_hotsax(dat, w_size = 100, paa_size = 4, a_size = 4, n_threshold = 0.01, discords_num = 5)
discords
# -->
# The best discord is the first one at 4233:
# ----------
graphics.off()
par(mfrow = c(1,1))
plot(dat, type = "l", col = "cornflowerblue")
lines(x = c(discords[1,2]:(discords[1,2] + 100)),
y = dat[discords[1,2]:(discords[1,2] + 100)], col = "red")
discords <- find_discords_hotsax(dat, w_size = 200, paa_size = 4, a_size = 4, n_threshold = 0.01, discords_num = 5)
discords
w_size <- 200
graphics.off()
par(mfrow = c(1,1))
plot(dat, type = "l", col = "cornflowerblue")
lines(x = c(discords[1,2]:(discords[1,2] + w_size)),
y = dat[discords[1,2]:(discords[1,2] + w_size)], col = "red")
w_size <- 100
discords <- find_discords_hotsax(dat, w_size = w_size, paa_size = 4, a_size = 4, n_threshold = 0.01, discords_num = 5)
discords
# -->
# The best discord is the first one at 4233:
which.max(discords["nn_distance",]
which.max(discords["nn_distance",])
which.max(discords["nn_distance",])
which.max(discords$nn_distance)
idx <- which.max(discords$nn_distance)
( idx <- discords$position[which.max(discords$nn_distance)] )
graphics.off()
par(mfrow = c(1,1))
plot(dat, type = "l", col = "cornflowerblue")
lines(x = c(idx:(idx + w_size)), y = dat[idx:(idx + w_size)], col = "red")
y_paa3 = paa(dat, 3)
y_paa3
paa(dat, 10)
sumamry(dat)
summary(dat)
hist(dat)
paa(dat, 10)
# data range
y = c(-1, -2, -1, 0, 2, 1, 1, 0)
( y_paa3 = paa(y, 3) )
plot(y)
dat
summary(dat)
hist(dat)
paa(dat, 10)
paa(dat[1:100], 10)
y <- c(-1, -2, -1, 0, 2, 1, 1, 0)
paa(y, 3)
plot(y, type = "l")
paa(y, 3)
abline(v = paa(y, 3), col = "blue", lty = 2)
abline(v = paa(y, 3)
y <- c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type = "l")
abline(h = paa(y, 3), col = "blue", lty = 2)
y <- c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type = "o")
abline(h = paa(y, 3), col = "blue", lty = 2)
# for example
y <- c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type = "o")
abline(v = c(3.5, 6.5), h = paa(y, 3), col = "blue", lty = 2)
y <- c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type = "o")
abline(v = c(3.5, 6.5), h = paa(y, 3), col = c("black", "blue", "red"), lty = 2)
y <- c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type = "o")
abline(v = c(3.5, 6.5), h = paa(y, 3), col = "blue", lty = 2, lwd = 2)
y = c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type="l", col="blue", main="8-points time series and it PAA transform into 3 points")
points(y, pch=16, lwd=5, col="blue")
abline(v=c(1,1+7/3,1+7/3*2,8), lty=3, lwd=2, col="gray50")
y_paa3 = paa(y, 3)
segments(1,y_paa3[1],1+7/3,y_paa3[1],lwd=1,col="red")
points(x=1+7/3/2,y=y_paa3[1],col="red",pch=23,lwd=5)
segments(1+7/3,y_paa3[2],1+7/3*2,y_paa3[2],lwd=1,col="red")
points(x=1+7/3+7/3/2,y=y_paa3[2],col="red",pch=23,lwd=5)
segments(1+7/3*2,y_paa3[3],8,y_paa3[3],lwd=1,col="red")
points(x=1+7/3*2+7/3/2,y=y_paa3[3],col="red",pch=23,lwd=5)
w_size <- 100
# paa_size:  the PAA size (Piecewise Aggregate Approximation)
# a_size:  the alphabet size
# discords_num:  number of discords to report
discords <- find_discords_hotsax(dat, w_size = w_size, paa_size = 4, a_size = 4, n_threshold = 0.01, discords_num = 5)
discords
# -->
# The best discord is the first one at 4233:
# ----------
( idx <- discords$position[which.max(discords$nn_distance)] )
# ----------
graphics.off()
par(mfrow = c(1,1))
plot(dat, type = "l", col = "cornflowerblue")
lines(x = c(idx:(idx + w_size)), y = dat[idx:(idx + w_size)], col = "red")
dat <- data[,3]
plot(dat, type = "l")
# window size is important !!!
w_size <- 100
# paa_size:  the PAA size (Piecewise Aggregate Approximation)
# a_size:  the alphabet size
# discords_num:  number of discords to report
discords <- find_discords_hotsax(dat, w_size = w_size, paa_size = 4, a_size = 4, n_threshold = 0.01, discords_num = 5)
discords
# -->
# The best discord is the first one at 4233:
# ----------
( idx <- discords$position[which.max(discords$nn_distance)] )
# ----------
graphics.off()
par(mfrow = c(1,1))
plot(dat, type = "l", col = "cornflowerblue")
lines(x = c(idx:(idx + w_size)), y = dat[idx:(idx + w_size)], col = "red")
w_size <- 100
# paa_size:  the PAA size (Piecewise Aggregate Approximation)
# a_size:  the alphabet size
# discords_num:  number of discords to report
discords <- find_discords_hotsax(dat, w_size = w_size, paa_size = 4, a_size = 10, n_threshold = 0.01, discords_num = 5)
discords
# ----------
( idx <- discords$position[which.max(discords$nn_distance)] )
# ----------
graphics.off()
par(mfrow = c(1,1))
plot(dat, type = "l", col = "cornflowerblue")
lines(x = c(idx:(idx + w_size)), y = dat[idx:(idx + w_size)], col = "red")
discords <- find_discords_hotsax(dat, w_size = w_size, paa_size = 4, a_size = 4, n_threshold = 0.01, discords_num = 5)
discords
# -->
# The best discord is the first one at 4233:
# ----------
( idx <- discords$position[which.max(discords$nn_distance)] )
# ----------
graphics.off()
par(mfrow = c(1,1))
plot(dat, type = "l", col = "cornflowerblue")
lines(x = c(idx:(idx + w_size)), y = dat[idx:(idx + w_size)], col = "red")
lines(x = c(idx:(idx + w_size)), y = dat[idx:(idx + w_size)], col = "red", lwd = 2)
# for example
y = c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type="l", col="blue", main="8-points time series and it PAA transform into 3 points")
points(y, pch=16, lwd=5, col="blue")
abline(v=c(1,1+7/3,1+7/3*2,8), lty=3, lwd=2, col="gray50")
y_paa3 = paa(y, 3)
segments(1,y_paa3[1],1+7/3,y_paa3[1],lwd=1,col="red")
points(x=1+7/3/2,y=y_paa3[1],col="red",pch=23,lwd=5)
segments(1+7/3,y_paa3[2],1+7/3*2,y_paa3[2],lwd=1,col="red")
points(x=1+7/3+7/3/2,y=y_paa3[2],col="red",pch=23,lwd=5)
segments(1+7/3*2,y_paa3[3],8,y_paa3[3],lwd=1,col="red")
points(x=1+7/3*2+7/3/2,y=y_paa3[3],col="red",pch=23,lwd=5)
y <- seq(-2,2, length=100)
x <- dnorm(y, mean=0, sd=1)
lines(x,y, type="l", lwd=5, col="magenta")
lines(x,y, type="l", lwd=5, col="magenta")
abline(h = alphabet_to_cuts(3)[2:3], lty=2, lwd=2, col="magenta")
alphabet_to_cuts(3)[2:3]
text(0.7,-1,"a",cex=2,col="magenta")
text(0.7, 0,"b",cex=2,col="magenta")
text(0.7, 1,"c",cex=2,col="magenta")
> series_to_string(y_paa3, 3)
[1] "acc"
> series_to_chars(y_paa3, 3)
series_to_string(y_paa3, 3)
series_to_chars(y_paa3, 3)
y = c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type="l", col="blue", main="8-points time series and it PAA transform into 3 points")
points(y, pch=16, lwd=5, col="blue")
abline(v=c(1,1+7/3,1+7/3*2,8), lty=3, lwd=2, col="gray50")
y_paa3 = paa(y, 3)
segments(1,y_paa3[1],1+7/3,y_paa3[1],lwd=1,col="red")
points(x=1+7/3/2,y=y_paa3[1],col="red",pch=23,lwd=5)
segments(1+7/3,y_paa3[2],1+7/3*2,y_paa3[2],lwd=1,col="red")
points(x=1+7/3+7/3/2,y=y_paa3[2],col="red",pch=23,lwd=5)
segments(1+7/3*2,y_paa3[3],8,y_paa3[3],lwd=1,col="red")
points(x=1+7/3*2+7/3/2,y=y_paa3[3],col="red",pch=23,lwd=5)
y <- seq(-2,2, length=100)
x <- dnorm(y, mean=0, sd=1)
lines(x,y, type="l", lwd=5, col="magenta")
abline(h = alphabet_to_cuts(3)[2:3], lty=2, lwd=2, col="magenta")
text(0.7,-1,"a",cex=2,col="magenta")
text(0.7, 0,"b",cex=2,col="magenta")
text(0.7, 1,"c",cex=2,col="magenta")
series_to_string(y_paa3, 3)
[1] "acc"
series_to_chars(y_paa3, 3)
y
x
y <- seq(-2,2, length=100)
x <- dnorm(y, mean=0, sd=1) + 1
lines(x,y, type="l", lwd=5, col="magenta")
abline(h = alphabet_to_cuts(3)[2:3], lty=2, lwd=2, col="magenta")
text(0.7,-1,"a",cex=2,col="magenta")
text(0.7, 0,"b",cex=2,col="magenta")
text(0.7, 1,"c",cex=2,col="magenta")
series_to_string(y_paa3, 3)
[1] "acc"
series_to_chars(y_paa3, 3)
y = c(-1, -2, -1, 0, 2, 1, 1, 0)
plot(y, type="l", col="blue", main="8-points time series and it PAA transform into 3 points")
points(y, pch=16, lwd=5, col="blue")
abline(v=c(1,1+7/3,1+7/3*2,8), lty=3, lwd=2, col="gray50")
y_paa3 = paa(y, 3)
segments(1,y_paa3[1],1+7/3,y_paa3[1],lwd=1,col="red")
points(x=1+7/3/2,y=y_paa3[1],col="red",pch=23,lwd=5)
segments(1+7/3,y_paa3[2],1+7/3*2,y_paa3[2],lwd=1,col="red")
points(x=1+7/3+7/3/2,y=y_paa3[2],col="red",pch=23,lwd=5)
segments(1+7/3*2,y_paa3[3],8,y_paa3[3],lwd=1,col="red")
points(x=1+7/3*2+7/3/2,y=y_paa3[3],col="red",pch=23,lwd=5)
y <- seq(-2,2, length=100)
x <- dnorm(y, mean=0, sd=1) + 1
lines(x,y, type="l", lwd=5, col="magenta")
abline(h = alphabet_to_cuts(3)[2:3], lty=2, lwd=2, col="magenta")
text(1.7,-1,"a",cex=2,col="magenta")
text(1.7, 0,"b",cex=2,col="magenta")
text(1.7, 1,"c",cex=2,col="magenta")
series_to_string(y_paa3, 3)
series_to_chars(y_paa3, 3)
y <- c(-1, -2, -1, 0, 2, 1, 1, 0)
y_paa3 <- paa(y, 3)
plot(y, type = "l", col = "blue", main = "8-points time series and it PAA transform into 3 points")
points(y, pch = 16, lwd = 5, col = "blue")
abline(v = c(1, 1+7/3, 1+7/3*2, 8), lty = 3, lwd = 2, col = "gray50")
segments(1,y_paa3[1],1+7/3,y_paa3[1],lwd=1,col="red")
points(x=1+7/3/2,y=y_paa3[1],col="red",pch=23,lwd=5)
segments(1+7/3,y_paa3[2],1+7/3*2,y_paa3[2],lwd=1,col="red")
points(x=1+7/3+7/3/2,y=y_paa3[2],col="red",pch=23,lwd=5)
segments(1+7/3*2,y_paa3[3],8,y_paa3[3],lwd=1,col="red")
points(x=1+7/3*2+7/3/2,y=y_paa3[3],col="red",pch=23,lwd=5)
y <- seq(-2,2, length=100)
x <- dnorm(y, mean=0, sd=1) + 1
lines(x,y, type="l", lwd=5, col="magenta")
abline(h = alphabet_to_cuts(3)[2:3], lty=2, lwd=2, col="magenta")
text(1.7,-1,"a",cex=2,col="magenta")
text(1.7, 0,"b",cex=2,col="magenta")
text(1.7, 1,"c",cex=2,col="magenta")
series_to_string(y_paa3, 3)
series_to_chars(y_paa3, 3)
grammar <- str_to_repair_grammar("abc abc cba cba bac xxx abc abc cba cba bac")
grammar
library(ggplot2)
df <- data.frame(time = c(1:length(dat)), value = dat)
p1 <- ggplot(df, aes(time, value)) + geom_line(lwd=1.1,color="blue1") + theme_classic() +
ggtitle("Dataset ECG qtdb 0606 [701-3000]") +
theme(plot.title = element_text(size = rel(1.5)),
axis.title.x = element_blank(),axis.title.y=element_blank(),
axis.ticks.y=element_blank(),axis.text.y=element_blank())
p1
p1 <- ggplot(df, aes(time, value)) + geom_line(lwd=1.1,color="blue1") + theme_classic()
p1
w <- 100
p <- 8
a <- 8
# discretize the data
dat_sax <- sax_via_window(dat, w, p, a, "none", 0.01)
# get the string representation of time series
dat_str <- paste(dat_sax, collapse=" ")
# infer the grammar
dat_grammar <- str_to_repair_grammar(dat_str)
# initialize the density curve
density_curve = rep(0,length(dat))
# account for all the rule intervals
for(i in 2:length(dat_grammar)){
rule = dat_grammar[[i]]
for(j in 1:length(rule$rule_interval_starts)){
xs = rule$rule_interval_starts[j]
xe = rule$rule_interval_ends[j] + w
density_curve[xs:xe] <- density_curve[xs:xe] + 1;
}
}
# see global minimas
which(density_curve==min(density_curve))
which(density_curve==min(density_curve))
density_df=data.frame(time=c(1:length(density_curve)),value=density_curve)
density_df
shade <- rbind(c(0,0), density_df, c(2229,0))
names(shade)<-c("x","y")
p2 <- ggplot(density_df, aes(x=time,y=value)) +
geom_line(col="cyan2") + theme_classic() +
geom_polygon(data = shade, aes(x, y), fill="cyan", alpha=0.5) +
ggtitle("RePair rules density for (w=100,p=8,a=8)") +
theme(plot.title = element_text(size = rel(1.5)), axis.title.x = element_blank(),
axis.title.y=element_blank(), axis.ticks.y=element_blank(),axis.text.y=element_blank())+
geom_line(data=min_values,aes(x,y),lwd=2,col="red")
p2
density_df = data.frame(time=c(1:length(density_curve)),value=density_curve)
density_df
plot(density_df, type = "l")
which(density_curve == min(density_curve, 6))
density_curve
par(mfrow = c(2,1))
plot(dat, type = "l")
plot(density_df, type = "l")
plot(density_curve, type = "l")
par(mfrow = c(2,1))
plot(dat, type = "l")
plot(density_curve, type = "l")
dat_sax <- sax_via_window(dat, w, p, a, "none", 0.01)
dat_sax
dat_str <- paste(dat_sax, collapse = " ")
dat_str
dat_grammar <- str_to_repair_grammar(dat_str)
str(dat_grammar[[2]])
ength(rule$rule_interval_starts)
length(rule$rule_interval_starts)
rule$rule_interval_starts
rule$rule_interval_starts
density_curve <- rep(0, length(dat))
rule$rule_interval_starts
# account for all the rule intervals
for(i in 2:length(dat_grammar)){
rule <- dat_grammar[[i]]
for(j in 1:length(rule$rule_interval_starts)){
xs <- rule$rule_interval_starts[j]
xe <- rule$rule_interval_ends[j] + w
density_curve[xs:xe] <- density_curve[xs:xe] + 1
}
}
rule$rule_interval_starts[j]
rule$rule_interval_ends[j] + w
density_curve[xs:xe]
density_curve <- rep(0, length(dat))
density_curve
i <- 1
rule <- dat_grammar[[i]]
rule
str(dat_grammar[[2]])
dat_grammar[[2]]
dat_sax
table(dat_sax)
str(dat_sax)
dat_sax
dat_sax[[1]]
# time point = 1,2
dat_sax[[1]]
dat_sax[[2]]
dat <- data[,3]
# ----------
# discretize the data
# discretization parameters
w <- 100
p <- 8
a <- 8
dat_sax <- sax_via_window(dat, w, p, a, "none", 0.01)
# time point = 1,2
dat_sax[[1]]
dat_sax[[2]]
# ----------
# get the string representation of time series
dat_str <- paste(dat_sax, collapse = " ")
dat_str
# infer the grammar
dat_grammar <- str_to_repair_grammar(dat_str)
# 1st rule of the grammar (second list element)
str(dat_grammar[[2]])
dat_grammar[[2]]
# ----------
# initialize the density curve
density_curve <- rep(0, length(dat))
rule$rule_interval_starts
# account for all the rule intervals
for(i in 2:length(dat_grammar)){
rule <- dat_grammar[[i]]
for(j in 1:length(rule$rule_interval_starts)){
xs <- rule$rule_interval_starts[j]
xe <- rule$rule_interval_ends[j] + w
density_curve[xs:xe] <- density_curve[xs:xe] + 1
}
}
# ----------
# plot the density curve
graphics.off()
par(mfrow = c(2,1))
plot(dat, type = "l")
plot(density_curve, type = "l")
dat <- data[,2]
# ----------
# discretize the data
# discretization parameters
w <- 100
p <- 8
a <- 8
dat_sax <- sax_via_window(dat, w, p, a, "none", 0.01)
# time point = 1,2
dat_sax[[1]]
dat_sax[[2]]
# ----------
# get the string representation of time series
dat_str <- paste(dat_sax, collapse = " ")
dat_str
# infer the grammar
dat_grammar <- str_to_repair_grammar(dat_str)
# 1st rule of the grammar (second list element)
str(dat_grammar[[2]])
dat_grammar[[2]]
# ----------
# initialize the density curve
density_curve <- rep(0, length(dat))
rule$rule_interval_starts
# account for all the rule intervals
for(i in 2:length(dat_grammar)){
rule <- dat_grammar[[i]]
for(j in 1:length(rule$rule_interval_starts)){
xs <- rule$rule_interval_starts[j]
xe <- rule$rule_interval_ends[j] + w
density_curve[xs:xe] <- density_curve[xs:xe] + 1
}
}
# ----------
# plot the density curve
graphics.off()
par(mfrow = c(2,1))
plot(dat, type = "l")
plot(density_curve, type = "l")
data("CBF")
str(CBF)
MTS::MTSplot(CBF)
MTS::MTSplot(cbind(CBF))
cbind(CBF)
bind_cols(CBF)
data(CBF, package = "CBF")
data(CBF, package = "jmotif")
str(CBF)
data.frame(CBF)
data <- t(data.frame(CBF))
head(data)
data <- unlist(CBF)
data
data.frame(matrix(unlist(CBF), ncol = 4, byrow = F),stringsAsFactors=FALSE)
data <- data.frame(matrix(unlist(CBF), ncol = 4, byrow = F),stringsAsFactors=FALSE)
data <- data.frame(matrix(unlist(CBF), ncol = 4, byrow = F), stringsAsFactors = FALSE)
head(data)
str(CBF)
CBF$data_train
w <- 60 # the sliding window size
p <- 6  # the PAA size
a <- 6  # the SAX alphabet size
# ----------
# convert the train classes to wordbags (the dataset has three labels: 1, 2, 3)
#
cylinder <- manyseries_to_wordbag(CBF[["data_train"]][CBF[["labels_train"]] == 1,], w, p, a, "exact", 0.01)
bell <- manyseries_to_wordbag(CBF[["data_train"]][CBF[["labels_train"]] == 2,], w, p, a, "exact", 0.01)
funnel <- manyseries_to_wordbag(CBF[["data_train"]][CBF[["labels_train"]] == 3,], w, p, a, "exact", 0.01)
cylinder
head(cylinder)
tfidf = bags_to_tfidf( list("cylinder" = cylinder, "bell" = bell, "funnel" = funnel) )
help("bags_to_tfidf")
tail(tfidf)
head(cylinder)
nrow(cylinder)
head(arrange(tfidf, desc(cylinder)))
ts.plot(tfidf[,2:4])
MST::MTSplot(tfidf[,2:4])
MTS::MTSplot(tfidf[,2:4])
sample = (CBF[["data_train"]][CBF[["labels_train"]] == 3,])[1,]
sample_bag = sax_via_window(sample, w, p, a, "exact", 0.01)
df = data.frame(index = as.numeric(names(sample_bag)), words = unlist(sample_bag))
# weight the found patterns
#
weighted_patterns = merge(df, tfidf)
specificity = rep(0, length(sample))
for(i in 1:length(weighted_patterns$words)){
pattern = weighted_patterns[i,]
for(j in 1:w){
specificity[pattern$index+j] = specificity[pattern$index+j] +
pattern$funnel - pattern$bell - pattern$cylinder
}
}
# plot the weighted patterns
#
library(ggplot2)
library(scales)
ggplot(data=data.frame(x=c(1:length(sample)), y=sample, col=rescale(specificity)),
aes(x=x,y=y,color=col)) + geom_line(size=1.2) + theme_bw() +
ggtitle("The funnel class-characteristic pattern example") +
scale_colour_gradientn(name = "Class specificity:  ",limits=c(0,1),
colours=c("red","yellow","green","lightblue","darkblue"),
breaks=c(0,0.5,1),labels=c("negative","neutral","high"),
guide = guide_colorbar(title.theme=element_text(size=14, angle=0),title.vjust=1,
barheight=0.6, barwidth=6, label.theme=element_text(size=10, angle=0))) +
theme(legend.position="bottom",plot.title=element_text(size=18),
axis.title.x=element_blank(), axis.title.y=element_blank(),
axis.text.x=element_text(size=12),axis.text.y=element_blank(),
panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(),
axis.ticks.y = element_blank())
CBF[["data_train"]][CBF[["labels_train"]] == 3,]
sample <- CBF[["data_train"]][CBF[["labels_train"]] == 3,]
dim(sample)
sample <- (CBF[["data_train"]][CBF[["labels_train"]] == 3,])[1,]
dim(sample)
sample
sample <- CBF[["data_train"]][CBF[["labels_train"]] == 3,]
dim(sample)
matplot(sample)
sample <- CBF[["data_train"]][CBF[["labels_train"]] == 3,]
dim(sample)
matplot(sample)
matplot(t(sample))
matplot(t(sample), type = "l")
sample_bag = sax_via_window(sample, w, p, a, "exact", 0.01)
df = data.frame(index = as.numeric(names(sample_bag)), words = unlist(sample_bag))
